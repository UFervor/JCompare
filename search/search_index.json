{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Just Compare is an open-source Python library designed to facilitate directory comparison.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Identify identical and different files using hash algorithms.</li> <li>Compare files for similarity and dissimilarity using customizable metrics.</li> <li>Identify identical and different files based on directory structures.</li> </ul>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Python &gt;= 3.10.0</p>"},{"location":"#installation","title":"Installation","text":"<p>To install Just Compare, run the following command in your terminal:</p> <pre><code>pip3 install jcompare\n</code></pre> <p>Or you can clone the repository and install:</p> <pre><code>git clone https://github.com/UFervor/JCompare.git\ncd JCompare\npip3 install .\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Visit the Helper section for more information, or for advanced usage, see the Core API section.</p>"},{"location":"coreAPI/","title":"Core API","text":""},{"location":"coreAPI/#compare-by-similarity","title":"Compare by Similarity","text":"<p>The similarity calculation is customizable; visit the metrics section for more information.</p>"},{"location":"coreAPI/#JCompare.similarity.find_similar_files_pairwise","title":"JCompare.similarity.find_similar_files_pairwise","text":"<pre><code>find_similar_files_pairwise(folder1: Folder, folder2: Folder, threshold: float, same_parent_only: bool, comparer: Similarity, mode: int) -&gt; dict[str, list[tuple[str, float]]]\n</code></pre> <p>Finds similar files between two folders in a pairwise manner.</p> <p>Parameters:</p> Name Type Description Default <code>folder1</code> <code>Folder</code> <p>The first folder object, which contains the files to be compared.</p> required <code>folder2</code> <code>Folder</code> <p>The second folder object, which contains the files to be compared.</p> required <code>threshold</code> <code>float</code> <p>The similarity threshold. Only pairs of files with a similarity score equal to or above this threshold will be included in the result.</p> required <code>same_parent_only</code> <code>bool</code> <p>If set to True, only files with the same parent directory will be compared.</p> required <code>comparer</code> <code>Similarity</code> <p>The similarity comparer object used to compare the files.</p> required <code>mode</code> <code>int</code> <p>The mode of operation. If set to SYNC, the function will use synchronous I/O. If set to ASYNC, the function will use asynchronous I/O. If set to ASYNC_AND_MULTIPROCESS, the function will use both asynchronous I/O and multiprocessing.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid mode is given.</p> <p>Returns:</p> Type Description <code>dict[str, list[tuple[str, float]]]</code> <p>dict[str, list[tuple[str, float]]]: A dictionary where each key is the relative path of a file in the first folder and each value is a list of tuples. Each tuple contains the relative path of a similar file in the second folder and the similarity score.</p> Source code in <code>JCompare/similarity.py</code> <pre><code>def find_similar_files_pairwise(folder1: Folder, folder2: Folder, threshold: float, same_parent_only: bool, comparer: Similarity, mode: int) -&gt; dict[str, list[tuple[str, float]]]:\n    \"\"\"\n    Finds similar files between two folders in a pairwise manner.\n\n    Args:\n        folder1 (Folder): The first folder object, which contains the files to be compared.\n        folder2 (Folder): The second folder object, which contains the files to be compared.\n        threshold (float): The similarity threshold. Only pairs of files with a similarity score equal to or above this threshold will be included in the result.\n        same_parent_only (bool): If set to True, only files with the same parent directory will be compared.\n        comparer (Similarity): The similarity comparer object used to compare the files.\n        mode (int): The mode of operation. If set to SYNC, the function will use synchronous I/O. If set to ASYNC, the function will use asynchronous I/O. If set to ASYNC_AND_MULTIPROCESS, the function will use both asynchronous I/O and multiprocessing.\n\n    Raises:\n        ValueError: If an invalid mode is given.\n\n    Returns:\n        dict[str, list[tuple[str, float]]]: A dictionary where each key is the relative path of a file in the first folder and each value is a list of tuples. Each tuple contains the relative path of a similar file in the second folder and the similarity score.\n    \"\"\"\n\n    files1 = folder1.list\n    files2 = folder2.list\n\n    pairs = [(file1, file2) for file1 in files1 for file2 in files2]\n\n    if same_parent_only:\n        pairs = [(file1, file2) for file1, file2 in pairs if os.path.dirname(\n            file1) == os.path.dirname(file2)]\n\n    if mode == SYNC:\n        similar_files = {}\n\n        for file1, file2 in tqdm(pairs, desc=\"Comparing files\", unit=\"pair\"):\n            file1_fulpath = os.path.join(folder1.folder_path, file1)\n            file2_fulpath = os.path.join(folder2.folder_path, file2)\n\n            similarity = comparer.cmp(\n                (file1_fulpath, file1), (file2_fulpath, file2))\n\n            if similarity &gt;= threshold:\n                if os.path.relpath(file1, folder1.path) not in similar_files:\n                    similar_files[os.path.relpath(file1, folder1.path)] = []\n                similar_files[os.path.relpath(file1, folder1.path)].append(\n                    (os.path.relpath(file2, folder2.path), similarity))\n\n        return similar_files\n\n    elif mode == ASYNC or mode == ASYNC_AND_MULTIPROCESS:\n        return asyncio.run(async_find_similar_files(pairs, folder1, folder2, threshold, comparer, mode))\n    else:\n        raise ValueError(\"Invalid Mode\")\n</code></pre>"},{"location":"coreAPI/#JCompare.similarity.find_dissimilar_files_pairwise","title":"JCompare.similarity.find_dissimilar_files_pairwise","text":"<pre><code>find_dissimilar_files_pairwise(folder1: Folder, folder2: Folder, threshold: float, same_parent_only: bool, comparer: Similarity, mode: int) -&gt; dict[str, Union[list[str], bool]]\n</code></pre> <p>Finds dissimilar files between two folders in a pairwise manner.</p> <p>Parameters:</p> Name Type Description Default <code>folder1</code> <code>Folder</code> <p>The first folder object, which contains the files to be compared.</p> required <code>folder2</code> <code>Folder</code> <p>The second folder object, which contains the files to be compared.</p> required <code>threshold</code> <code>float</code> <p>The similarity threshold. Only pairs of files with a similarity score below this threshold will be included in the result.</p> required <code>same_parent_only</code> <code>bool</code> <p>If set to True, only files with the same parent directory will be compared.</p> required <code>comparer</code> <code>Similarity</code> <p>The similarity comparer object used to compare the files.</p> required <code>mode</code> <code>int</code> <p>The mode of operation. If set to SYNC, the function will use synchronous I/O. If set to ASYNC, the function will use asynchronous I/O. If set to ASYNC_AND_MULTIPROCESS, the function will use both asynchronous I/O and multiprocessing.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid mode is given.</p> <p>Returns:</p> Type Description <code>dict[str, Union[list[str], bool]]</code> <p>dict[str, Union[list[str],  bool]]: A dictionary with three keys: 'folder1', 'folder2', and 'is_similar'. The value of 'folder1' is a list of the relative paths of the dissimilar files in the first folder. The value of 'folder2' is a list of the relative paths of the dissimilar files in the second folder. The value of 'is_similar' is a boolean indicating whether the two folders are similar.</p> Source code in <code>JCompare/similarity.py</code> <pre><code>def find_dissimilar_files_pairwise(folder1: Folder, folder2: Folder, threshold: float, same_parent_only: bool, comparer: Similarity, mode: int) -&gt; dict[str, Union[list[str],  bool]]:\n    \"\"\"\n    Finds dissimilar files between two folders in a pairwise manner.\n\n    Args:\n        folder1 (Folder): The first folder object, which contains the files to be compared.\n        folder2 (Folder): The second folder object, which contains the files to be compared.\n        threshold (float): The similarity threshold. Only pairs of files with a similarity score below this threshold will be included in the result.\n        same_parent_only (bool): If set to True, only files with the same parent directory will be compared.\n        comparer (Similarity): The similarity comparer object used to compare the files.\n        mode (int): The mode of operation. If set to SYNC, the function will use synchronous I/O. If set to ASYNC, the function will use asynchronous I/O. If set to ASYNC_AND_MULTIPROCESS, the function will use both asynchronous I/O and multiprocessing.\n\n    Raises:\n        ValueError: If an invalid mode is given.\n\n    Returns:\n        dict[str, Union[list[str],  bool]]: A dictionary with three keys: 'folder1', 'folder2', and 'is_similar'. The value of 'folder1' is a list of the relative paths of the dissimilar files in the first folder. The value of 'folder2' is a list of the relative paths of the dissimilar files in the second folder. The value of 'is_similar' is a boolean indicating whether the two folders are similar.\n    \"\"\"\n\n    if same_parent_only:\n        pairs = find_common_path(folder1.tree, folder2.tree)\n        files1_list = [i[0] for i in pairs]\n        files2_list = [i[1] for i in pairs]\n    else:\n        files1_list = folder1.list\n        files2_list = folder2.list\n        pairs = tuple((file1, file2)\n                      for file1 in files1_list for file2 in files2_list)\n\n    dissimilar_files_folder1 = {i: 0 for i in files1_list}\n    dissimilar_files_folder2 = {i: 0 for i in files2_list}\n\n    if mode == SYNC:\n        for file1, file2 in tqdm(pairs, desc=\"Comparing files\", unit=\"pair\"):\n            if dissimilar_files_folder1[file1] &gt;= threshold and dissimilar_files_folder2[file2] &gt;= threshold:\n                continue\n\n            file1_fulpath = os.path.join(folder1.folder_path, file1)\n            file2_fulpath = os.path.join(folder2.folder_path, file2)\n\n            similarity = comparer.cmp(\n                (file1_fulpath, file1), (file2_fulpath, file2))\n\n            dissimilar_files_folder1[file1] = max(\n                similarity, dissimilar_files_folder1[file1])\n            dissimilar_files_folder2[file2] = max(\n                similarity, dissimilar_files_folder2[file2])\n\n    elif mode == ASYNC or mode == ASYNC_AND_MULTIPROCESS:\n        dissimilar_files_folder1, dissimilar_files_folder2 = asyncio.run(async_find_dissimilar_files(pairs, dissimilar_files_folder1, dissimilar_files_folder2, folder1, folder2,\n                                                                                                     comparer, mode))\n    else:\n        raise ValueError(\"Invalid Mode\")\n\n    dissimilar_files_folder1 = [os.path.relpath(i[0], folder1.path) for i in filter(\n        lambda item: item[1] &lt; threshold, dissimilar_files_folder1.items())]\n    dissimilar_files_folder2 = [os.path.relpath(i[0], folder2.path) for i in filter(\n        lambda item: item[1] &lt; threshold, dissimilar_files_folder2.items())]\n\n    is_similar = not (dissimilar_files_folder1 or dissimilar_files_folder2)\n\n    result = {\n        \"folder1\": dissimilar_files_folder1,\n        \"folder2\": dissimilar_files_folder2,\n        \"is_similar\": is_similar\n    }\n\n    return result\n</code></pre>"},{"location":"coreAPI/#compare-by-hash","title":"Compare by Hash","text":""},{"location":"coreAPI/#JCompare.hash.find_identical_files","title":"JCompare.hash.find_identical_files","text":"<pre><code>find_identical_files(folder1: Folder, folder2: Folder, same_parent_only: bool, hash_algorithm: tuple[str]) -&gt; dict[str, list[str]]\n</code></pre> <p>Finds identical files between two folders based on their hash values.</p> <p>Parameters:</p> Name Type Description Default <code>folder1</code> <code>Folder</code> <p>The first folder object, which contains the files to be compared.</p> required <code>folder2</code> <code>Folder</code> <p>The second folder object, which contains the files to be compared.</p> required <code>same_parent_only</code> <code>bool</code> <p>If set to True, only files with the same parent folder will be compared.</p> required <code>hash_algorithm</code> <code>tuple[str]</code> <p>A tuple of strings specifying the names of the hash algorithms to use.</p> required <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>dict[str, list[str]]: A dictionary mapping the relative paths of the identical files in the first folder to lists of the relative paths of the identical files in the second folder.</p> Source code in <code>JCompare/hash.py</code> <pre><code>def find_identical_files(folder1: Folder, folder2: Folder, same_parent_only: bool, hash_algorithm: tuple[str]) -&gt; dict[str, list[str]]:\n    \"\"\"\n    Finds identical files between two folders based on their hash values.\n\n    Args:\n        folder1 (Folder): The first folder object, which contains the files to be compared.\n        folder2 (Folder): The second folder object, which contains the files to be compared.\n        same_parent_only (bool): If set to True, only files with the same parent folder will be compared.\n        hash_algorithm (tuple[str]): A tuple of strings specifying the names of the hash algorithms to use.\n\n    Returns:\n        dict[str, list[str]]: A dictionary mapping the relative paths of the identical files in the first folder to lists of the relative paths of the identical files in the second folder.\n    \"\"\"\n\n    if same_parent_only:\n        pairs = find_common_path(folder1.tree, folder2.tree)\n        files1_list = [i[0] for i in pairs]\n        files2_list = [i[1] for i in pairs]\n    else:\n        files1_list = folder1.list\n        files2_list = folder2.list\n        pairs = tuple((file1, file2)\n                      for file1 in files1_list for file2 in files2_list)\n\n    files1_list = list(set(files1_list))\n    files2_list = list(set(files2_list))\n\n    hash_dict1, hash_dict2 = calculate_hash(\n        files1_list, files2_list, folder1, folder2, hash_algorithm)\n\n    identical_files = {}\n\n    for file1, file2 in pairs:\n        if hash_dict1[file1] == hash_dict2[file2]:\n            file1_relpath = os.path.relpath(file1, folder1.path)\n            file2_relpath = os.path.relpath(file2, folder2.path)\n\n            if file1_relpath not in identical_files:\n                identical_files[file1_relpath] = []\n            identical_files[file1_relpath].append(file2_relpath)\n\n    return identical_files\n</code></pre>"},{"location":"coreAPI/#JCompare.hash.find_different_files","title":"JCompare.hash.find_different_files","text":"<pre><code>find_different_files(folder1: Folder, folder2: Folder, same_parent_only: bool, hash_algorithm: tuple[str]) -&gt; dict[str, Union[list[str], bool]]\n</code></pre> <p>Finds different files between two folders based on their hash values.</p> <p>Parameters:</p> Name Type Description Default <code>folder1</code> <code>Folder</code> <p>The first folder object, which contains the files to be compared.</p> required <code>folder2</code> <code>Folder</code> <p>The second folder object, which contains the files to be compared.</p> required <code>same_parent_only</code> <code>bool</code> <p>If set to True, only files with the same parent folder will be compared.</p> required <code>hash_algorithm</code> <code>tuple[str]</code> <p>A tuple of strings specifying the names of the hash algorithms to use.</p> required <p>Returns:</p> Type Description <code>dict[str, Union[list[str], bool]]</code> <p>dict[str, Union[list[str], bool]]: A dictionary with keys \"folder1\", \"folder2\", and \"is_identical\". The values for \"folder1\" and \"folder2\" are lists of the relative paths of the different files in the respective folders. The value for \"is_identical\" is a boolean indicating whether the two folders are identical.</p> Source code in <code>JCompare/hash.py</code> <pre><code>def find_different_files(folder1: Folder, folder2: Folder, same_parent_only: bool, hash_algorithm: tuple[str]) -&gt; dict[str, Union[list[str], bool]]:\n    \"\"\"\n    Finds different files between two folders based on their hash values.\n\n    Args:\n        folder1 (Folder): The first folder object, which contains the files to be compared.\n        folder2 (Folder): The second folder object, which contains the files to be compared.\n        same_parent_only (bool): If set to True, only files with the same parent folder will be compared.\n        hash_algorithm (tuple[str]): A tuple of strings specifying the names of the hash algorithms to use.\n\n    Returns:\n        dict[str, Union[list[str], bool]]: A dictionary with keys \"folder1\", \"folder2\", and \"is_identical\". The values for \"folder1\" and \"folder2\" are lists of the relative paths of the different files in the respective folders. The value for \"is_identical\" is a boolean indicating whether the two folders are identical.\n    \"\"\"\n\n    if same_parent_only:\n        pairs = find_common_path(folder1.tree, folder2.tree)\n        files1_list = [i[0] for i in pairs]\n        files2_list = [i[1] for i in pairs]\n    else:\n        files1_list = folder1.list\n        files2_list = folder2.list\n        pairs = tuple((file1, file2)\n                      for file1 in files1_list for file2 in files2_list)\n\n    files1_list = list(set(files1_list))\n    files2_list = list(set(files2_list))\n\n    hash_dict1, hash_dict2 = calculate_hash(\n        files1_list, files2_list, folder1, folder2, hash_algorithm)\n\n    name_dict1 = {i: [] for i in files1_list}\n    name_dict2 = {i: [] for i in files2_list}\n    for file1, file2 in pairs:\n        name_dict1[file1].append(file2)\n        name_dict2[file2].append(file1)\n\n    different_files_folder1 = []\n    different_files_folder2 = []\n\n    for file1, file1_hash in hash_dict1.items():\n        if file1_hash not in [hash_dict2[i] for i in name_dict1[file1]]:\n            different_files_folder1.append(\n                os.path.relpath(file1, folder1.path))\n\n    for file2, file2_hash in hash_dict2.items():\n        if file2_hash not in [hash_dict1[i] for i in name_dict2[file2]]:\n            different_files_folder2.append(\n                os.path.relpath(file2, folder2.path))\n\n    is_identical = not (different_files_folder1 or different_files_folder2)\n\n    result = {\n        \"folder1\": different_files_folder1,\n        \"folder2\": different_files_folder2,\n        \"is_identical\": is_identical\n    }\n\n    return result\n</code></pre>"},{"location":"coreAPI/#compare-by-directory-structure","title":"Compare by Directory Structure","text":""},{"location":"coreAPI/#JCompare.mcs.find_identical_files_by_mcs","title":"JCompare.mcs.find_identical_files_by_mcs","text":"<pre><code>find_identical_files_by_mcs(folder1: Folder, folder2: Folder, ignore_directory_names: bool = False, path: None | tuple[tuple[str], tuple[str]] = None) -&gt; list[dict[str, list[str]]]\n</code></pre> <p>Finds identical files between two folders based on the maximum common subtree (MCS).</p> <p>Parameters:</p> Name Type Description Default <code>folder1</code> <code>Folder</code> <p>The first folder object, which contains the files to be compared.</p> required <code>folder2</code> <code>Folder</code> <p>The second folder object, which contains the files to be compared.</p> required <code>ignore_directory_names</code> <code>bool</code> <p>If set to True, directory names will be ignored when comparing the folder structures. Defaults to False.</p> <code>False</code> <code>path</code> <code>None | tuple[tuple[str], tuple[str]]</code> <p>A tuple of two tuples, each containing the path to a subtree in the corresponding folder. If provided, only the specified subtrees will be compared. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, list[str]]]</code> <p>list[dict[str, list[str]]]: A list of dictionaries. Each dictionary represents a set of identical files in an MCS (there might be multiple), with the keys being the relative paths of the files in the first folder and the values being lists of the relative paths of the identical files in the second folder.</p> Source code in <code>JCompare/mcs.py</code> <pre><code>def find_identical_files_by_mcs(folder1: Folder, folder2: Folder, ignore_directory_names: bool = False, path: None | tuple[tuple[str], tuple[str]] = None) -&gt; list[dict[str, list[str]]]:\n    \"\"\"\n    Finds identical files between two folders based on the maximum common subtree (MCS).\n\n    Args:\n        folder1 (Folder): The first folder object, which contains the files to be compared.\n        folder2 (Folder): The second folder object, which contains the files to be compared.\n        ignore_directory_names (bool, optional): If set to True, directory names will be ignored when comparing the folder structures. Defaults to False.\n        path (None | tuple[tuple[str], tuple[str]], optional): A tuple of two tuples, each containing the path to a subtree in the corresponding folder. If provided, only the specified subtrees will be compared. Defaults to None.\n\n    Returns:\n        list[dict[str, list[str]]]: A list of dictionaries. Each dictionary represents a set of identical files in an MCS (there might be multiple), with the keys being the relative paths of the files in the first folder and the values being lists of the relative paths of the identical files in the second folder.\n    \"\"\"\n\n    if path == None:\n        tree1 = folder1.tree\n        tree2 = folder2.tree\n        subtrees = find_max_common_subtree(\n            tree1, tree2, ignore_directory_names)\n    else:\n        tree1 = folder1.tree\n        tree2 = folder2.tree\n        for i in path[0]:\n            tree1 = tree1[i]\n        for i in path[1]:\n            tree2 = tree2[i]\n        subtrees = [[find_common_subtree(tree1, tree2, ignore_directory_names)[\n            0], path[0], path[1]]]\n\n    results = []\n\n    if path == None:\n        path = ((), ())\n\n    for subtree in subtrees:\n        tmp = {}\n        for i in dict2list(subtree[0]):\n            file1 = \"../\" + \\\n                \"/\".join(list(path[0]) + [j[0]\n                         if isinstance(j, tuple) else j for j in i])\n            file2 = \"../\" + \\\n                \"/\".join(list(path[1]) + [j[1]\n                         if isinstance(j, tuple) else j for j in i])\n            tmp[file1] = [file2]\n        results.append(tmp)\n\n    return results\n</code></pre>"},{"location":"coreAPI/#JCompare.mcs.find_different_files_by_mcs","title":"JCompare.mcs.find_different_files_by_mcs","text":"<pre><code>find_different_files_by_mcs(folder1: Folder, folder2: Folder, ignore_directory_names: bool = False, path: None | tuple[tuple[str], tuple[str]] = None) -&gt; list[dict[str, list[str] | str, bool]]\n</code></pre> <p>Finds different files between two folders based on the maximum common subtree (MCS).</p> <p>Parameters:</p> Name Type Description Default <code>folder1</code> <code>Folder</code> <p>The first folder object, which contains the files to be compared.</p> required <code>folder2</code> <code>Folder</code> <p>The second folder object, which contains the files to be compared.</p> required <code>ignore_directory_names</code> <code>bool</code> <p>If set to True, directory names will be ignored when comparing the folder structures. Defaults to False.</p> <code>False</code> <code>path</code> <code>None | tuple[tuple[str], tuple[str]]</code> <p>A tuple of two tuples, each containing the path to a subtree in the corresponding folder. If provided, only the specified subtrees will be compared. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, list[str] | str, bool]]</code> <p>list[dict[str, list[str] | str, bool]]: A list of dictionaries. Each dictionary represents a set of different files in an MCS (there might be multiple), with the keys being the relative paths of the files in the first and second folder and a boolean indicating whether the files are identical or not.</p> Source code in <code>JCompare/mcs.py</code> <pre><code>def find_different_files_by_mcs(folder1: Folder, folder2: Folder, ignore_directory_names: bool = False, path: None | tuple[tuple[str], tuple[str]] = None) -&gt; list[dict[str, list[str] | str, bool]]:\n    \"\"\"\n    Finds different files between two folders based on the maximum common subtree (MCS).\n\n    Args:\n        folder1 (Folder): The first folder object, which contains the files to be compared.\n        folder2 (Folder): The second folder object, which contains the files to be compared.\n        ignore_directory_names (bool, optional): If set to True, directory names will be ignored when comparing the folder structures. Defaults to False.\n        path (None | tuple[tuple[str], tuple[str]], optional): A tuple of two tuples, each containing the path to a subtree in the corresponding folder. If provided, only the specified subtrees will be compared. Defaults to None.\n\n    Returns:\n        list[dict[str, list[str] | str, bool]]: A list of dictionaries. Each dictionary represents a set of different files in an MCS (there might be multiple), with the keys being the relative paths of the files in the first and second folder and a boolean indicating whether the files are identical or not.\n    \"\"\"\n\n    if path == None:\n        tree1 = folder1.tree\n        tree2 = folder2.tree\n        subtrees = find_max_common_subtree(\n            tree1, tree2, ignore_directory_names)\n    else:\n        tree1 = folder1.tree\n        tree2 = folder2.tree\n        for i in path[0]:\n            tree1 = tree1[i]\n        for i in path[1]:\n            tree2 = tree2[i]\n        subtrees = [[find_common_subtree(tree1, tree2, ignore_directory_names)[\n            0], path[0], path[1]]]\n\n    results = []\n\n    for subtree in subtrees:\n        if ignore_directory_names:\n            f1_tree, f2_tree = folder1.tree, folder2.tree\n        else:\n            f1_tree, f2_tree = rm_common_node(folder1.tree, folder2.tree)\n\n        tree1, tree2 = subtract_max_common_subtree(\n            f1_tree, f2_tree, subtree)\n        results.append({\n            \"folder1\": tree2path(tree1),\n            \"folder2\": tree2path(tree2),\n            \"is_identical\": not tree1 and not tree2\n        })\n    return results\n</code></pre>"},{"location":"examples/","title":"Usage Examples","text":""},{"location":"examples/#helper-function","title":"Helper Function","text":""},{"location":"examples/#comparing-files-for-identical-content","title":"Comparing Files for Identical Content","text":"<pre><code>from JCompare import print_identical_files\nfrom JCompare import Folder\n\nfolder1 = Folder(\"/path/to/folder\")\nfolder2 = Folder(\"/path/to/archive.zip\")\n\nfolder2.extract()\n\nprint_identical_files(folder1, folder2)\n</code></pre>"},{"location":"examples/#finding-similar-files","title":"Finding Similar Files","text":"<pre><code>from JCompare import Folder, CompressionSimilarity, print_similar_files\n\nfolder1 = Folder(\"/path/to/folder1\")\nfolder2 = Folder(\"/path/to/folder2\")\n\nprint_similar_files(folder1, folder2, threshold=0.9, comparer=CompressionSimilarity(\"zstd\"))\n</code></pre>"},{"location":"examples/#comparing-files-by-directory-structures","title":"Comparing Files by Directory Structures","text":"<pre><code>from JCompare import print_identical_files\nfrom JCompare import Folder\n\nfolder1 = Folder(\"/path/to/folder\")\nfolder2 = Folder(\"/path/to/archive.zip\")\n\nprint_different_files_by_mcs(folder1, folder2, ignore_directory_names=True)\n</code></pre>"},{"location":"helper/","title":"Helpers","text":""},{"location":"helper/#compare-by-similarity","title":"Compare by Similarity","text":"<p>The similarity calculation is customizable; visit the metrics section for more information.</p>"},{"location":"helper/#JCompare.print_similar_files","title":"JCompare.print_similar_files","text":"<pre><code>print_similar_files(folder1: Folder, folder2: Folder, threshold: float, same_parent_only: bool = False, comparer: Similarity = CompressionSimilarity('lzma2'), mode: int = ASYNC_AND_MULTIPROCESS) -&gt; None\n</code></pre> <p>Prints the similar files between two folders based on a similarity threshold.</p> <p>Parameters:</p> Name Type Description Default <code>folder1</code> <code>Folder</code> <p>The first folder object, which contains the files to be compared.</p> required <code>folder2</code> <code>Folder</code> <p>The second folder object, which contains the files to be compared.</p> required <code>threshold</code> <code>float</code> <p>The similarity threshold. Only files with a similarity score above this threshold will be considered similar.</p> required <code>same_parent_only</code> <code>bool</code> <p>If set to True, only files with the same parent folder will be compared. Defaults to False.</p> <code>False</code> <code>comparer</code> <code>Similarity</code> <p>The similarity comparer to use. Defaults to CompressionSimilarity(\"lzma2\").</p> <code>CompressionSimilarity('lzma2')</code> <code>mode</code> <code>int</code> <p>The mode to use for comparison. Defaults to ASYNC_AND_MULTIPROCESS.</p> <code>ASYNC_AND_MULTIPROCESS</code> Source code in <code>JCompare/compare.py</code> <pre><code>def print_similar_files(folder1: Folder, folder2: Folder, threshold: float, same_parent_only: bool = False, comparer: Similarity = CompressionSimilarity(\"lzma2\"), mode: int = ASYNC_AND_MULTIPROCESS) -&gt; None:\n    \"\"\"\n    Prints the similar files between two folders based on a similarity threshold.\n\n    Args:\n        folder1 (Folder): The first folder object, which contains the files to be compared.\n        folder2 (Folder): The second folder object, which contains the files to be compared.\n        threshold (float): The similarity threshold. Only files with a similarity score above this threshold will be considered similar.\n        same_parent_only (bool, optional): If set to True, only files with the same parent folder will be compared. Defaults to False.\n        comparer (Similarity, optional): The similarity comparer to use. Defaults to CompressionSimilarity(\"lzma2\").\n        mode (int, optional): The mode to use for comparison. Defaults to ASYNC_AND_MULTIPROCESS.\n    \"\"\"\n\n    result = find_similar_files_pairwise(\n        folder1, folder2, threshold, same_parent_only, comparer, mode)\n\n    for key, value in result.items():\n        print(f\"+ {key}\")\n        for i in value:\n            print(f\"  - {i[0]} {i[1]*100:.2f}%\")\n</code></pre>"},{"location":"helper/#JCompare.print_dissimilar_files","title":"JCompare.print_dissimilar_files","text":"<pre><code>print_dissimilar_files(folder1: Folder, folder2: Folder, threshold: float, same_parent_only: bool = False, comparer: Similarity = CompressionSimilarity('lzma2'), mode: int = ASYNC_AND_MULTIPROCESS) -&gt; None\n</code></pre> <p>Prints the dissimilar files between two folders based on a similarity threshold.</p> <p>Parameters:</p> Name Type Description Default <code>folder1</code> <code>Folder</code> <p>The first folder object, which contains the files to be compared.</p> required <code>folder2</code> <code>Folder</code> <p>The second folder object, which contains the files to be compared.</p> required <code>threshold</code> <code>float</code> <p>The similarity threshold. Only files with a similarity score below this threshold will be considered dissimilar.</p> required <code>same_parent_only</code> <code>bool</code> <p>If set to True, only files with the same parent folder will be compared. Defaults to False.</p> <code>False</code> <code>comparer</code> <code>Similarity</code> <p>The similarity comparer to use. Defaults to CompressionSimilarity(\"lzma2\").</p> <code>CompressionSimilarity('lzma2')</code> <code>mode</code> <code>int</code> <p>The mode to use for comparison. Defaults to ASYNC_AND_MULTIPROCESS.</p> <code>ASYNC_AND_MULTIPROCESS</code> Source code in <code>JCompare/compare.py</code> <pre><code>def print_dissimilar_files(folder1: Folder, folder2: Folder, threshold: float, same_parent_only: bool = False, comparer: Similarity = CompressionSimilarity(\"lzma2\"), mode: int = ASYNC_AND_MULTIPROCESS) -&gt; None:\n    \"\"\"\n    Prints the dissimilar files between two folders based on a similarity threshold.\n\n    Args:\n        folder1 (Folder): The first folder object, which contains the files to be compared.\n        folder2 (Folder): The second folder object, which contains the files to be compared.\n        threshold (float): The similarity threshold. Only files with a similarity score below this threshold will be considered dissimilar.\n        same_parent_only (bool, optional): If set to True, only files with the same parent folder will be compared. Defaults to False.\n        comparer (Similarity, optional): The similarity comparer to use. Defaults to CompressionSimilarity(\"lzma2\").\n        mode (int, optional): The mode to use for comparison. Defaults to ASYNC_AND_MULTIPROCESS.\n    \"\"\"\n\n    result = find_dissimilar_files_pairwise(\n        folder1, folder2, threshold, same_parent_only, comparer, mode)\n\n    if result[\"is_similar\"]:\n        print(\"The folders are similar.\")\n    else:\n        print(\"Dissimilar files found:\")\n        if result[\"folder1\"]:\n            print(f\"Only in folder1:\")\n            for i in result['folder1']:\n                print(f\"+ {i}\")\n        if result[\"folder2\"]:\n            print(f\"Only in folder2:\")\n            for i in result['folder2']:\n                print(f\"+ {i}\")\n</code></pre>"},{"location":"helper/#compare-by-hash","title":"Compare by Hash","text":""},{"location":"helper/#JCompare.print_identical_files","title":"JCompare.print_identical_files","text":"<pre><code>print_identical_files(folder1: Folder, folder2: Folder, same_parent_only: bool = False, hash_algorithm: tuple[str] = ('sha256')) -&gt; None\n</code></pre> <p>Prints the identical files between two folders based on their hash values.</p> <p>Parameters:</p> Name Type Description Default <code>folder1</code> <code>Folder</code> <p>The first folder object, which contains the files to be compared.</p> required <code>folder2</code> <code>Folder</code> <p>The second folder object, which contains the files to be compared.</p> required <code>same_parent_only</code> <code>bool</code> <p>If set to True, only files with the same parent folder will be compared. Defaults to False.</p> <code>False</code> <code>hash_algorithm</code> <code>tuple[str]</code> <p>A tuple of strings specifying the names of the hash algorithms to use. Defaults to (\"sha256\",).</p> <code>('sha256')</code> Source code in <code>JCompare/compare.py</code> <pre><code>def print_identical_files(folder1: Folder, folder2: Folder, same_parent_only: bool = False, hash_algorithm: tuple[str] = (\"sha256\",)) -&gt; None:\n    \"\"\"\n    Prints the identical files between two folders based on their hash values.\n\n    Args:\n        folder1 (Folder): The first folder object, which contains the files to be compared.\n        folder2 (Folder): The second folder object, which contains the files to be compared.\n        same_parent_only (bool, optional): If set to True, only files with the same parent folder will be compared. Defaults to False.\n        hash_algorithm (tuple[str], optional): A tuple of strings specifying the names of the hash algorithms to use. Defaults to (\"sha256\",).\n    \"\"\"\n\n    result = find_identical_files(\n        folder1, folder2, same_parent_only, hash_algorithm)\n\n    for key, value in result.items():\n        print(f\"+ {key}\")\n        for i in value:\n            print(f\"  - {i}\")\n</code></pre>"},{"location":"helper/#JCompare.print_different_files","title":"JCompare.print_different_files","text":"<pre><code>print_different_files(folder1: Folder, folder2: Folder, same_parent_only: bool = False, hash_algorithm: tuple[str] = ('sha256')) -&gt; None\n</code></pre> <p>Prints the different files between two folders based on their hash values.</p> <p>Parameters:</p> Name Type Description Default <code>folder1</code> <code>Folder</code> <p>The first folder object, which contains the files to be compared.</p> required <code>folder2</code> <code>Folder</code> <p>The second folder object, which contains the files to be compared.</p> required <code>same_parent_only</code> <code>bool</code> <p>If set to True, only files with the same parent folder will be compared. Defaults to False.</p> <code>False</code> <code>hash_algorithm</code> <code>tuple[str]</code> <p>A tuple of strings specifying the names of the hash algorithms to use. Defaults to (\"sha256\",).</p> <code>('sha256')</code> Source code in <code>JCompare/compare.py</code> <pre><code>def print_different_files(folder1: Folder, folder2: Folder, same_parent_only: bool = False, hash_algorithm: tuple[str] = (\"sha256\",)) -&gt; None:\n    \"\"\"\n    Prints the different files between two folders based on their hash values.\n\n    Args:\n        folder1 (Folder): The first folder object, which contains the files to be compared.\n        folder2 (Folder): The second folder object, which contains the files to be compared.\n        same_parent_only (bool, optional): If set to True, only files with the same parent folder will be compared. Defaults to False.\n        hash_algorithm (tuple[str], optional): A tuple of strings specifying the names of the hash algorithms to use. Defaults to (\"sha256\",).\n    \"\"\"\n\n    result = find_different_files(\n        folder1, folder2, same_parent_only, hash_algorithm)\n\n    if result[\"is_identical\"]:\n        print(\"The folders are identical.\")\n    else:\n        print(\"Different files found:\")\n        if result['folder1']:\n            print(f\"Only in folder1:\")\n            for i in result['folder1']:\n                print(f\"+ {i}\")\n        if result['folder2']:\n            print(f\"Only in folder2:\")\n            for i in result['folder2']:\n                print(f\"+ {i}\")\n</code></pre>"},{"location":"helper/#compare-by-directory-structure","title":"Compare by Directory Structure","text":""},{"location":"helper/#JCompare.print_identical_files_by_mcs","title":"JCompare.print_identical_files_by_mcs","text":"<pre><code>print_identical_files_by_mcs(folder1: Folder, folder2: Folder, ignore_directory_names: bool = False, path: None | tuple[tuple[str], tuple[str]] = None) -&gt; None\n</code></pre> <p>Prints the identical files between two folders based on the maximum common subtree (MCS).</p> <p>Parameters:</p> Name Type Description Default <code>folder1</code> <code>Folder</code> <p>The first folder object, which contains the files to be compared.</p> required <code>folder2</code> <code>Folder</code> <p>The second folder object, which contains the files to be compared.</p> required <code>ignore_directory_names</code> <code>bool</code> <p>If set to True, directory names will be ignored when comparing the folder structures. Defaults to False.</p> <code>False</code> <code>path</code> <code>None | tuple[tuple[str], tuple[str]]</code> <p>A tuple of two tuples, each containing the path to a subtree in the corresponding folder. If provided, only the specified subtrees will be compared. Defaults to None.</p> <code>None</code> Source code in <code>JCompare/compare.py</code> <pre><code>def print_identical_files_by_mcs(folder1: Folder, folder2: Folder, ignore_directory_names: bool = False, path: None | tuple[tuple[str], tuple[str]] = None) -&gt; None:\n    \"\"\"\n    Prints the identical files between two folders based on the maximum common subtree (MCS).\n\n    Args:\n        folder1 (Folder): The first folder object, which contains the files to be compared.\n        folder2 (Folder): The second folder object, which contains the files to be compared.\n        ignore_directory_names (bool, optional): If set to True, directory names will be ignored when comparing the folder structures. Defaults to False.\n        path (None | tuple[tuple[str], tuple[str]], optional): A tuple of two tuples, each containing the path to a subtree in the corresponding folder. If provided, only the specified subtrees will be compared. Defaults to None.\n    \"\"\"\n\n    results = find_identical_files_by_mcs(\n        folder1, folder2, ignore_directory_names, path)\n\n    for result in results:\n        for key, value in result.items():\n            print(f\"+ {key}\")\n            for i in value:\n                print(f\"  - {i}\")\n</code></pre>"},{"location":"helper/#JCompare.print_different_files_by_mcs","title":"JCompare.print_different_files_by_mcs","text":"<pre><code>print_different_files_by_mcs(folder1: Folder, folder2: Folder, ignore_directory_names: bool = False, path: None | tuple[tuple[str], tuple[str]] = None) -&gt; None\n</code></pre> <p>Prints the different files between two folders based on the maximum common subtree (MCS).</p> <p>Parameters:</p> Name Type Description Default <code>folder1</code> <code>Folder</code> <p>The first folder object, which contains the files to be compared.</p> required <code>folder2</code> <code>Folder</code> <p>The second folder object, which contains the files to be compared.</p> required <code>ignore_directory_names</code> <code>bool</code> <p>If set to True, directory names will be ignored when comparing the folder structures. Defaults to False.</p> <code>False</code> <code>path</code> <code>None | tuple[tuple[str], tuple[str]]</code> <p>A tuple of two tuples, each containing the path to a subtree in the corresponding folder. If provided, only the specified subtrees will be compared. Defaults to None.</p> <code>None</code> Source code in <code>JCompare/compare.py</code> <pre><code>def print_different_files_by_mcs(folder1: Folder, folder2: Folder, ignore_directory_names: bool = False, path: None | tuple[tuple[str], tuple[str]] = None) -&gt; None:\n    \"\"\"\n    Prints the different files between two folders based on the maximum common subtree (MCS).\n\n    Args:\n        folder1 (Folder): The first folder object, which contains the files to be compared.\n        folder2 (Folder): The second folder object, which contains the files to be compared.\n        ignore_directory_names (bool, optional): If set to True, directory names will be ignored when comparing the folder structures. Defaults to False.\n        path (None | tuple[tuple[str], tuple[str]], optional): A tuple of two tuples, each containing the path to a subtree in the corresponding folder. If provided, only the specified subtrees will be compared. Defaults to None.\n    \"\"\"\n\n    results = find_different_files_by_mcs(\n        folder1, folder2, ignore_directory_names, path)\n\n    for result in results:\n        if result[\"is_identical\"]:\n            print(\"The folders are identical.\")\n        else:\n            print(\"Different files found:\")\n            if result['folder1']:\n                print(f\"Only in folder1:\")\n                for i in result['folder1']:\n                    print(f\"+ {i}\")\n            if result['folder2']:\n                print(f\"Only in folder2:\")\n                for i in result['folder2']:\n                    print(f\"+ {i}\")\n</code></pre>"},{"location":"metrics/","title":"Metrics","text":""},{"location":"metrics/#similarity","title":"Similarity","text":"<p>To customize similarity calculation, implement your desired way by inheriting the Similarity class. The comparer calculates the similarity between two files by calling the <code>cmp</code> member function.</p>"},{"location":"metrics/#JCompare.metrics.Similarity","title":"JCompare.metrics.Similarity","text":"<p>Base class for implementing similarity metrics.</p> <p>This class provides a structure for implementing different similarity metrics.  Subclasses should override the <code>cmp</code> method to provide their own similarity calculation logic.</p> Source code in <code>JCompare/metrics.py</code> <pre><code>class Similarity:\n    \"\"\"\n    Base class for implementing similarity metrics.\n\n    This class provides a structure for implementing different similarity metrics. \n    Subclasses should override the `cmp` method to provide their own similarity calculation logic.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initializes a new instance of the Similarity class.\n        \"\"\"\n\n        ...\n\n    def cmp(self, file1: tuple[str, str], file2: tuple[str, str]) -&gt; float:\n        \"\"\"\n        Compares two files for similarity.\n\n        Args:\n            file1 (tuple[str, str]): A tuple containing the full path and the relative path of the first file.\n            file2 (tuple[str, str]): A tuple containing the full path and the relative path of the second file.\n\n        Raises:\n            NotImplementedError: This method must be implemented in a subclass.\n\n        Returns:\n            float: The similarity score between the two files. The score is a float between 0 and 1, where 0 means completely dissimilar and 1 means identical.\n        \"\"\"\n\n        fullpath1, relpath1 = file1\n        fullpath2, relpath2 = file2\n\n        raise NotImplementedError(\n            \"This method must be implemented in a subclass\")\n</code></pre>"},{"location":"metrics/#JCompare.metrics.Similarity.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initializes a new instance of the Similarity class.</p> Source code in <code>JCompare/metrics.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initializes a new instance of the Similarity class.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"metrics/#JCompare.metrics.Similarity.cmp","title":"cmp","text":"<pre><code>cmp(file1: tuple[str, str], file2: tuple[str, str]) -&gt; float\n</code></pre> <p>Compares two files for similarity.</p> <p>Parameters:</p> Name Type Description Default <code>file1</code> <code>tuple[str, str]</code> <p>A tuple containing the full path and the relative path of the first file.</p> required <code>file2</code> <code>tuple[str, str]</code> <p>A tuple containing the full path and the relative path of the second file.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method must be implemented in a subclass.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The similarity score between the two files. The score is a float between 0 and 1, where 0 means completely dissimilar and 1 means identical.</p> Source code in <code>JCompare/metrics.py</code> <pre><code>def cmp(self, file1: tuple[str, str], file2: tuple[str, str]) -&gt; float:\n    \"\"\"\n    Compares two files for similarity.\n\n    Args:\n        file1 (tuple[str, str]): A tuple containing the full path and the relative path of the first file.\n        file2 (tuple[str, str]): A tuple containing the full path and the relative path of the second file.\n\n    Raises:\n        NotImplementedError: This method must be implemented in a subclass.\n\n    Returns:\n        float: The similarity score between the two files. The score is a float between 0 and 1, where 0 means completely dissimilar and 1 means identical.\n    \"\"\"\n\n    fullpath1, relpath1 = file1\n    fullpath2, relpath2 = file2\n\n    raise NotImplementedError(\n        \"This method must be implemented in a subclass\")\n</code></pre>"},{"location":"metrics/#JCompare.CompressionSimilarity","title":"JCompare.CompressionSimilarity","text":"<p>             Bases: <code>Similarity</code></p> <p>A class used to compare the similarity between two files based on their compression ratio.</p> <p>This class inherits from the <code>Similarity</code> base class and overrides the <code>cmp</code> method to provide a similarity metric based on the compression ratio of the files. The compression ratio is calculated using a specified compression algorithm.</p> Source code in <code>JCompare/metrics.py</code> <pre><code>class CompressionSimilarity(Similarity):\n    \"\"\"\n    A class used to compare the similarity between two files based on their compression ratio.\n\n    This class inherits from the `Similarity` base class and overrides the `cmp` method to provide a similarity metric based on the compression ratio of the files. The compression ratio is calculated using a specified compression algorithm.\n    \"\"\"\n\n    def __init__(self, algorithm: str, level: None | int = None, chuck_size: int = 64 * 1024) -&gt; None:\n        \"\"\"\n        Initializes a new instance of the CompressionSimilarity class.\n\n        Args:\n            algorithm (str): The compression algorithm to use. Supported algorithms are 'lzma', 'lzma2', 'zstd', and 'brotli'.\n            level (int, optional): The compression level. If not provided, a default level will be used based on the algorithm.\n            chunk_size (int, optional): The size of the chunks to read from the files. Defaults to 64 kilobytes.\n\n        Raises:\n            ValueError: If an unsupported algorithm is given.\n        \"\"\"\n\n        super().__init__()\n        self.algorithm = algorithm\n        self.chunk_size = chuck_size\n        if level is None:\n            if algorithm == 'lzma':\n                self.level = 6\n            elif algorithm == 'lzma2':\n                self.level = 6\n            elif algorithm == 'zstd':\n                self.level = 13\n            elif algorithm == 'brotli':\n                self.level = 8\n            else:\n                raise ValueError(\"Unsupported Algorithm\")\n        else:\n            self.level = level\n\n    def cmp(self, file1: tuple[str, str], file2: tuple[str, str]) -&gt; float:\n        \"\"\"\n        Compares two files for similarity based on the compression ratio.\n\n        Args:\n            file1 (tuple[str, str]): A tuple containing the full path and the relative path of the first file.\n            file2 (tuple[str, str]): A tuple containing the full path and the relative path of the second file.\n\n        Raises:\n            ValueError: If an unsupported algorithm is given.\n\n        Returns:\n            float: The similarity score between the two files. The score is a float between 0 and 1, where 0 means completely dissimilar and 1 means identical.\n        \"\"\"\n\n        fullpath1, relpath1 = file1\n        fullpath2, relpath2 = file2\n\n        def compress_files(filepaths, algorithm):\n            compressor = None\n            compressed_length = 0\n\n            if algorithm == 'lzma':\n                compressor = lzma.LZMACompressor(format=lzma.FORMAT_ALONE, filters=[\n                                                 {\"id\": lzma.FILTER_LZMA1, \"preset\": self.level}])\n            elif algorithm == 'lzma2':\n                compressor = lzma.LZMACompressor(format=lzma.FORMAT_XZ, filters=[\n                                                 {\"id\": lzma.FILTER_LZMA2, \"preset\": self.level}])\n            elif algorithm == 'zstd':\n                compressor = zstandard.ZstdCompressor(\n                    level=self.level).compressobj()\n\n            elif algorithm == 'brotli':\n                compressor = brotli.Compressor(quality=self.level)\n                for filepath in filepaths:\n                    with open(filepath, 'rb') as f:\n                        for chunk in iter(lambda: f.read(self.chunk_size), b''):\n                            compressed_chunk = compressor.process(chunk)\n                            compressed_length += len(compressed_chunk)\n                compressed_length += len(compressor.finish())\n\n                return compressed_length\n\n            else:\n                raise ValueError(\"Unsupported Algorithm\")\n\n            for filepath in filepaths:\n                with open(filepath, 'rb') as f:\n                    for chunk in iter(lambda: f.read(self.chunk_size), b''):\n                        compressed_chunk = compressor.compress(chunk)\n                        compressed_length += len(compressed_chunk)\n            compressed_length += len(compressor.flush())\n\n            return compressed_length\n\n        c1_len = compress_files([fullpath1], self.algorithm)\n        c2_len = compress_files([fullpath2], self.algorithm)\n        cc_len = compress_files([fullpath1, fullpath2], self.algorithm)\n\n        similarity = min(\n            max(1 - (cc_len - min(c1_len, c2_len)) / (max(c1_len, c2_len)), 0), 1)\n        return similarity\n</code></pre>"},{"location":"metrics/#JCompare.CompressionSimilarity.__init__","title":"__init__","text":"<pre><code>__init__(algorithm: str, level: None | int = None, chuck_size: int = 64 * 1024) -&gt; None\n</code></pre> <p>Initializes a new instance of the CompressionSimilarity class.</p> <p>Parameters:</p> Name Type Description Default <code>algorithm</code> <code>str</code> <p>The compression algorithm to use. Supported algorithms are 'lzma', 'lzma2', 'zstd', and 'brotli'.</p> required <code>level</code> <code>int</code> <p>The compression level. If not provided, a default level will be used based on the algorithm.</p> <code>None</code> <code>chunk_size</code> <code>int</code> <p>The size of the chunks to read from the files. Defaults to 64 kilobytes.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported algorithm is given.</p> Source code in <code>JCompare/metrics.py</code> <pre><code>def __init__(self, algorithm: str, level: None | int = None, chuck_size: int = 64 * 1024) -&gt; None:\n    \"\"\"\n    Initializes a new instance of the CompressionSimilarity class.\n\n    Args:\n        algorithm (str): The compression algorithm to use. Supported algorithms are 'lzma', 'lzma2', 'zstd', and 'brotli'.\n        level (int, optional): The compression level. If not provided, a default level will be used based on the algorithm.\n        chunk_size (int, optional): The size of the chunks to read from the files. Defaults to 64 kilobytes.\n\n    Raises:\n        ValueError: If an unsupported algorithm is given.\n    \"\"\"\n\n    super().__init__()\n    self.algorithm = algorithm\n    self.chunk_size = chuck_size\n    if level is None:\n        if algorithm == 'lzma':\n            self.level = 6\n        elif algorithm == 'lzma2':\n            self.level = 6\n        elif algorithm == 'zstd':\n            self.level = 13\n        elif algorithm == 'brotli':\n            self.level = 8\n        else:\n            raise ValueError(\"Unsupported Algorithm\")\n    else:\n        self.level = level\n</code></pre>"},{"location":"metrics/#JCompare.CompressionSimilarity.cmp","title":"cmp","text":"<pre><code>cmp(file1: tuple[str, str], file2: tuple[str, str]) -&gt; float\n</code></pre> <p>Compares two files for similarity based on the compression ratio.</p> <p>Parameters:</p> Name Type Description Default <code>file1</code> <code>tuple[str, str]</code> <p>A tuple containing the full path and the relative path of the first file.</p> required <code>file2</code> <code>tuple[str, str]</code> <p>A tuple containing the full path and the relative path of the second file.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported algorithm is given.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The similarity score between the two files. The score is a float between 0 and 1, where 0 means completely dissimilar and 1 means identical.</p> Source code in <code>JCompare/metrics.py</code> <pre><code>def cmp(self, file1: tuple[str, str], file2: tuple[str, str]) -&gt; float:\n    \"\"\"\n    Compares two files for similarity based on the compression ratio.\n\n    Args:\n        file1 (tuple[str, str]): A tuple containing the full path and the relative path of the first file.\n        file2 (tuple[str, str]): A tuple containing the full path and the relative path of the second file.\n\n    Raises:\n        ValueError: If an unsupported algorithm is given.\n\n    Returns:\n        float: The similarity score between the two files. The score is a float between 0 and 1, where 0 means completely dissimilar and 1 means identical.\n    \"\"\"\n\n    fullpath1, relpath1 = file1\n    fullpath2, relpath2 = file2\n\n    def compress_files(filepaths, algorithm):\n        compressor = None\n        compressed_length = 0\n\n        if algorithm == 'lzma':\n            compressor = lzma.LZMACompressor(format=lzma.FORMAT_ALONE, filters=[\n                                             {\"id\": lzma.FILTER_LZMA1, \"preset\": self.level}])\n        elif algorithm == 'lzma2':\n            compressor = lzma.LZMACompressor(format=lzma.FORMAT_XZ, filters=[\n                                             {\"id\": lzma.FILTER_LZMA2, \"preset\": self.level}])\n        elif algorithm == 'zstd':\n            compressor = zstandard.ZstdCompressor(\n                level=self.level).compressobj()\n\n        elif algorithm == 'brotli':\n            compressor = brotli.Compressor(quality=self.level)\n            for filepath in filepaths:\n                with open(filepath, 'rb') as f:\n                    for chunk in iter(lambda: f.read(self.chunk_size), b''):\n                        compressed_chunk = compressor.process(chunk)\n                        compressed_length += len(compressed_chunk)\n            compressed_length += len(compressor.finish())\n\n            return compressed_length\n\n        else:\n            raise ValueError(\"Unsupported Algorithm\")\n\n        for filepath in filepaths:\n            with open(filepath, 'rb') as f:\n                for chunk in iter(lambda: f.read(self.chunk_size), b''):\n                    compressed_chunk = compressor.compress(chunk)\n                    compressed_length += len(compressed_chunk)\n        compressed_length += len(compressor.flush())\n\n        return compressed_length\n\n    c1_len = compress_files([fullpath1], self.algorithm)\n    c2_len = compress_files([fullpath2], self.algorithm)\n    cc_len = compress_files([fullpath1, fullpath2], self.algorithm)\n\n    similarity = min(\n        max(1 - (cc_len - min(c1_len, c2_len)) / (max(c1_len, c2_len)), 0), 1)\n    return similarity\n</code></pre>"}]}